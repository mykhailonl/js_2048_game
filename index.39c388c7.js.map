{"mappings":"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","sources":["<anon>","src/scripts/main.js","src/modules/Game.class.js"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/* eslint-disable padding-line-between-statements */ var $a5fd07fa01589658$exports = {};\n/* eslint-disable no-console */ /* eslint-disable padding-line-between-statements */ \"use strict\";\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */ class $a5fd07fa01589658$var$Game {\n    /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */ constructor(initialState = []){\n        if (initialState.length) this.initialState = initialState;\n        else this.initialState = [\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ]\n        ];\n        this.status = \"idle\";\n        this.score = 0;\n        this.currentState = this.initialState.map((row)=>[\n                ...row\n            ]);\n    }\n    /**\n   * Checks the games status and shows win/lose message\n   */ isGameOver() {\n        if (this.getStatus() === \"lose\") document.querySelector(\".message-lose\").classList.remove(\"hidden\");\n        else if (this.getStatus() === \"win\") document.querySelector(\".message-win\").classList.remove(\"hidden\");\n    }\n    /**\n   *\n   * @returns true if there is 2048 tile on the field, false otherwise\n   */ checkWinCondition() {\n        return this.currentState.some((row)=>row.includes(2048));\n    }\n    /**\n   *\n   * @returns true if player has at least 1 move, othrwise false\n   */ checkMovePossibility() {\n        if (this.getEmptyCellsCoordinates().length > 0) return true;\n        for(let row = 0; row < 4; row++)for(let col = 0; col < 4; col++){\n            const currentValue = this.checkCellByCoordinates([\n                row,\n                col\n            ]);\n            if (col < 3 && currentValue === this.checkCellByCoordinates([\n                row,\n                col + 1\n            ])) return true;\n            if (row < 3 && currentValue === this.checkCellByCoordinates([\n                row + 1,\n                col\n            ])) return true;\n        }\n        return false;\n    }\n    /**\n   * @description Moves all tiles down.\n   * Starting from the bottom-right corner, moving left and up,\n   * each non-empty cell is moved down as far as possible\n   * and merged if applicable.\n   * After the movement, a new tile is generated and the board is updated.\n   */ moveDown() {\n        if (this.getStatus() !== \"playing\") return;\n        const previousState = JSON.stringify(this.currentState);\n        for(let col = 3; col >= 0; col--){\n            const mergedThisMove = [\n                false,\n                false,\n                false,\n                false\n            ];\n            for(let row = 3; row >= 0; row--){\n                const currentValue = this.checkCellByCoordinates([\n                    row,\n                    col\n                ]);\n                if (currentValue !== 0) {\n                    let currentRow = row;\n                    let nextRow = currentRow + 1;\n                    // Move the tile down until it hits a non-empty cell\n                    //  or the bottom of the board\n                    while(nextRow <= 3 && this.checkCellByCoordinates([\n                        nextRow,\n                        col\n                    ]) === 0){\n                        this.currentState[nextRow][col] = currentValue;\n                        this.currentState[currentRow][col] = 0;\n                        currentRow = nextRow;\n                        nextRow++;\n                    }\n                    // Check for a possible merge\n                    if (nextRow <= 3 && this.checkCellByCoordinates([\n                        nextRow,\n                        col\n                    ]) === currentValue && !mergedThisMove[nextRow]) {\n                        // Merge\n                        this.currentState[nextRow][col] *= 2;\n                        this.currentState[currentRow][col] = 0;\n                        this.score += this.currentState[nextRow][col];\n                        mergedThisMove[nextRow] = true;\n                    }\n                }\n            }\n        }\n        const newState = JSON.stringify(this.currentState);\n        if (previousState === newState) return;\n        if (this.checkWinCondition()) this.status = \"win\";\n        this.generateAndPositionNewTile();\n        this.updateTheBoard();\n        if (!this.checkMovePossibility()) this.status = \"lose\";\n    }\n    /**\n   * @description Moves all tiles up.\n   * Starting from the top-left corner, moving right and down,\n   * each non-empty cell is moved up as far as possible\n   * and merged if applicable.\n   * After the movement, a new tile is generated and the board is updated.\n   */ moveUp() {\n        if (this.getStatus() !== \"playing\") return;\n        const previousState = JSON.stringify(this.currentState);\n        for(let col = 0; col < 4; col++){\n            const mergedThisMove = [\n                false,\n                false,\n                false,\n                false\n            ];\n            for(let row = 0; row < 4; row++){\n                const currentValue = this.checkCellByCoordinates([\n                    row,\n                    col\n                ]);\n                if (currentValue !== 0) {\n                    let currentRow = row;\n                    let nextRow = currentRow - 1;\n                    // Move the tile up until it hits a non-empty cell\n                    // or the top of the board\n                    while(nextRow >= 0 && this.checkCellByCoordinates([\n                        nextRow,\n                        col\n                    ]) === 0){\n                        this.currentState[nextRow][col] = currentValue;\n                        this.currentState[currentRow][col] = 0;\n                        currentRow = nextRow;\n                        nextRow--;\n                    }\n                    // Check for a possible merge\n                    if (nextRow >= 0 && this.checkCellByCoordinates([\n                        nextRow,\n                        col\n                    ]) === currentValue && !mergedThisMove[nextRow]) {\n                        // Merge\n                        this.currentState[nextRow][col] *= 2;\n                        this.currentState[currentRow][col] = 0;\n                        this.score += this.currentState[nextRow][col];\n                        mergedThisMove[nextRow] = true;\n                    }\n                }\n            }\n        }\n        const newState = JSON.stringify(this.currentState);\n        if (previousState === newState) return;\n        if (this.checkWinCondition()) this.status = \"win\";\n        this.generateAndPositionNewTile();\n        this.updateTheBoard();\n        if (!this.checkMovePossibility()) this.status = \"lose\";\n    }\n    /**\n   * @description Moves all tiles left.\n   * Starting from the top-left corner, moving right and down,\n   * each non-empty cell is moved left as far as possible\n   * and merged if applicable.\n   * After the movement, a new tile is generated and the board is updated.\n   */ moveLeft() {\n        if (this.getStatus() !== \"playing\") return;\n        const previousState = JSON.stringify(this.currentState);\n        for(let row = 0; row < 4; row++){\n            let newRow = this.currentState[row].filter((cell)=>cell !== 0);\n            newRow = [\n                ...newRow,\n                ...Array(4 - newRow.length).fill(0)\n            ];\n            this.currentState[row] = newRow;\n            const mergedThisMove = [\n                false,\n                false,\n                false,\n                false\n            ];\n            for(let col = 0; col < 3; col++){\n                const currentValue = this.checkCellByCoordinates([\n                    row,\n                    col\n                ]);\n                if (currentValue !== 0 && this.checkCellByCoordinates([\n                    row,\n                    col + 1\n                ]) === currentValue && !mergedThisMove[col]) {\n                    this.currentState[row][col] *= 2;\n                    this.currentState[row][col + 1] = 0;\n                    this.score += this.currentState[row][col];\n                    mergedThisMove[col] = true;\n                }\n            }\n            newRow = this.currentState[row].filter((cell)=>cell !== 0);\n            newRow = [\n                ...newRow,\n                ...Array(4 - newRow.length).fill(0)\n            ];\n            this.currentState[row] = newRow;\n        }\n        const newState = JSON.stringify(this.currentState);\n        if (previousState === newState) return;\n        if (this.checkWinCondition()) this.status = \"win\";\n        this.generateAndPositionNewTile();\n        this.updateTheBoard();\n        if (!this.checkMovePossibility()) this.status = \"lose\";\n    }\n    /**\n   * @description Moves all tiles right.\n   * Starting from the top-right corner, moving left and down,\n   * each non-empty cell is moved right as far as possible\n   * and merged if applicable.\n   * After the movement, a new tile is generated and the board is updated.\n   */ moveRight() {\n        if (this.getStatus() !== \"playing\") return;\n        const previousState = JSON.stringify(this.currentState);\n        for(let row = 0; row < 4; row++){\n            let newRow = this.currentState[row].filter((cell)=>cell !== 0);\n            newRow = [\n                ...Array(4 - newRow.length).fill(0),\n                ...newRow\n            ];\n            this.currentState[row] = newRow;\n            const mergedThisMove = [\n                false,\n                false,\n                false,\n                false\n            ];\n            for(let col = 3; col > 0; col--){\n                const currentValue = this.checkCellByCoordinates([\n                    row,\n                    col\n                ]);\n                if (currentValue !== 0 && this.checkCellByCoordinates([\n                    row,\n                    col - 1\n                ]) === currentValue && !mergedThisMove[col]) {\n                    this.currentState[row][col] *= 2;\n                    this.currentState[row][col - 1] = 0;\n                    this.score += this.currentState[row][col];\n                    mergedThisMove[col] = true;\n                }\n            }\n            newRow = this.currentState[row].filter((cell)=>cell !== 0);\n            newRow = [\n                ...Array(4 - newRow.length).fill(0),\n                ...newRow\n            ];\n            this.currentState[row] = newRow;\n        }\n        const newState = JSON.stringify(this.currentState);\n        if (previousState === newState) return;\n        if (this.checkWinCondition()) this.status = \"win\";\n        this.generateAndPositionNewTile();\n        this.updateTheBoard();\n        if (!this.checkMovePossibility()) this.status = \"lose\";\n    }\n    /**\n   * @description Simply holds an update of the visual score,\n   * called after each move in the main file.\n   */ updateTheScore() {\n        const scoreElement = document.querySelector(\".game-score\");\n        scoreElement.innerText = this.score;\n    }\n    /**\n   * @returns {number} returns game score.\n   */ getScore() {\n        return this.score;\n    }\n    /**\n   * @returns {number[][]} returns current game board state.\n   */ getState() {\n        return this.currentState;\n    }\n    /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */ getStatus() {\n        return this.status;\n    }\n    /**\n   * Calls two\n   *  @method generateNewTile\n   *\n   * and\n   *  @method positionNewTile\n   *\n   * in a chain to simplify the code read.\n   */ generateAndPositionNewTile() {\n        this.positionNewTile(this.generateNewTile());\n    }\n    /**\n   * Creates and positions 2 new cells on the field.\n   */ initializeBoard() {\n        this.generateAndPositionNewTile();\n        this.generateAndPositionNewTile();\n    }\n    /**\n   * @description Starts the game.\n   * Changing a status, initializing the board with 2 random cells\n   * and updating UI.\n   */ start() {\n        this.status = \"playing\";\n        this.initializeBoard();\n        this.updateTheBoard();\n    }\n    /**\n   * @description Resets the game.\n   * Setting a score to 0, clearing the field and calling a start() again.\n   */ restart() {\n        this.score = 0;\n        this.status = \"idle\";\n        this.currentState = this.initialState.map((row)=>[\n                ...row\n            ]);\n        this.updateTheBoard();\n    // this.updateTheScore();\n    }\n    /**\n   * @description Mapping through all non-empty cells, asiging 0 value to them,\n   * calling updateTheBoard() which check and fixes the styles\n   */ resetTheField() {\n        const cellsToReset = this.getNonEmptyCells();\n        const currentFieldState = this.getState();\n        cellsToReset.forEach((cell)=>{\n            currentFieldState[cell[0]][cell[1]] = 0;\n        });\n        this.updateTheBoard();\n    }\n    /**\n   * @returns {number} 2 or 4, 4 has 10% chance to be generated\n   */ generateNewTile() {\n        return Math.random() < 0.1 ? 4 : 2;\n    }\n    /**\n   * Sets new random position for the passed cellValue\n   * from available empty cell spots\n   * @param {number} newTileValue - number value of new cell to place\n   * @example 2, 4, 8, etc\n   */ positionNewTile(newTileValue) {\n        const availableFields = this.getEmptyCellsCoordinates();\n        const position = availableFields[Math.floor(Math.random() * availableFields.length)];\n        if (availableFields.length) this.getState()[position[0]][position[1]] = newTileValue;\n        else this.checkMovePossibility();\n    }\n    /**\n   * @example[[0, 1], [3,2]] etc\n   * @returns {number[][]} returns all empty cell coordinates array\n   */ getEmptyCellsCoordinates() {\n        const possibleCoordinates = [];\n        for(let row = 0; row < this.getState().length; row++){\n            for(let cell = 0; cell < this.getState()[row].length; cell++)if (this.currentState[row][cell] === 0) possibleCoordinates.push([\n                row,\n                cell\n            ]);\n        }\n        return possibleCoordinates;\n    }\n    /**\n   * @example [[0, 1], [3,2]] etc\n   * @returns {number[][]} returns all non-empty cell coordinates array\n   */ getNonEmptyCells() {\n        const cellsCoordinates = [];\n        for(let row = 0; row < this.getState().length; row++){\n            for(let cell = 0; cell < this.getState()[row].length; cell++)if (this.currentState[row][cell] !== 0) cellsCoordinates.push([\n                row,\n                cell\n            ]);\n        }\n        return cellsCoordinates;\n    }\n    /**\n   * @param {number[]} coordinatesToCheck - array of the cell coordinates\n   *  [x, y]\n   * @returns {number} cell value by the coordinates\n   */ checkCellByCoordinates([row, col]) {\n        if (row >= 0 && row < 4 && col >= 0 && col < 4) return this.currentState[row][col];\n        return null;\n    }\n    /**\n   * Updates UI of the board.\n   * @description Mapping through all rows/cells, clearing previous styles,\n   * changing cells according to updated game board.\n   */ updateTheBoard() {\n        const gameField = [\n            ...document.querySelectorAll(\"tr.field-row\")\n        ];\n        const rows = this.currentState;\n        if (gameField.length === 0) return;\n        // Going through rows\n        for(let i = 0; i < rows.length; i++)// Going through cells in row\n        for(let j = 0; j < rows[i].length; j++){\n            const currentCell = gameField[i].children[j];\n            const currentDataCell = rows[i][j];\n            // Removing all previous classes and setting a base class for the cell\n            currentCell.className = \"field-cell\";\n            // Adding an extra class, if cell is not empty\n            if (currentDataCell !== 0) {\n                currentCell.classList.add(`field-cell--${currentDataCell}`);\n                currentCell.innerText = currentDataCell;\n            } else currentCell.innerText = \"\";\n        }\n    }\n}\n$a5fd07fa01589658$exports = $a5fd07fa01589658$var$Game;\n\n\n\"use strict\";\nconst $09e991522ca7e64e$var$game = new (0, (/*@__PURE__*/$parcel$interopDefault($a5fd07fa01589658$exports)))();\nconst $09e991522ca7e64e$var$changeStartButton = (button)=>{\n    button.classList.remove(\"start\");\n    button.classList.add(\"restart\");\n    button.innerText = \"Restart\";\n};\nconst $09e991522ca7e64e$var$hideMessageContainer = ()=>{\n    const messageContainer = [\n        ...document.querySelectorAll(\".message\")\n    ];\n    messageContainer.forEach((message)=>message.classList.add(\"hidden\"));\n};\nconst $09e991522ca7e64e$var$initializeGame = ()=>{\n    const startButton = document.querySelector(\".button\");\n    if (startButton) startButton.addEventListener(\"click\", ()=>{\n        if ($09e991522ca7e64e$var$game.getStatus() === \"idle\") {\n            $09e991522ca7e64e$var$game.start();\n            $09e991522ca7e64e$var$changeStartButton(startButton);\n            $09e991522ca7e64e$var$hideMessageContainer();\n        } else if ($09e991522ca7e64e$var$game.getStatus() === \"playing\") {\n            $09e991522ca7e64e$var$game.restart();\n            $09e991522ca7e64e$var$game.start();\n        } else if ($09e991522ca7e64e$var$game.getStatus() === \"lose\") {\n            $09e991522ca7e64e$var$game.restart();\n            $09e991522ca7e64e$var$game.start();\n            $09e991522ca7e64e$var$hideMessageContainer();\n        }\n    });\n};\ndocument.addEventListener(\"DOMContentLoaded\", $09e991522ca7e64e$var$initializeGame);\n// eslint-disable-next-line no-shadow\ndocument.addEventListener(\"keydown\", (event)=>{\n    if ([\n        \"ArrowUp\",\n        \"ArrowDown\",\n        \"ArrowLeft\",\n        \"ArrowRight\"\n    ].includes(event.key)) event.preventDefault();\n    if ($09e991522ca7e64e$var$game.getStatus() !== \"playing\") return;\n    switch(event.key){\n        case \"ArrowUp\":\n            $09e991522ca7e64e$var$game.moveUp();\n            break;\n        case \"ArrowDown\":\n            $09e991522ca7e64e$var$game.moveDown();\n            break;\n        case \"ArrowLeft\":\n            $09e991522ca7e64e$var$game.moveLeft();\n            break;\n        case \"ArrowRight\":\n            $09e991522ca7e64e$var$game.moveRight();\n            break;\n    }\n    if ($09e991522ca7e64e$var$game.getStatus() === \"win\" || $09e991522ca7e64e$var$game.getStatus() === \"lose\") $09e991522ca7e64e$var$game.isGameOver();\n    $09e991522ca7e64e$var$game.updateTheScore();\n    $09e991522ca7e64e$var$game.updateTheBoard();\n});\n\n\n//# sourceMappingURL=index.39c388c7.js.map\n","/* eslint-disable padding-line-between-statements */\n'use strict';\n\nimport Game from '../modules/Game.class';\nconst game = new Game();\n\nconst changeStartButton = (button) => {\n  button.classList.remove('start');\n  button.classList.add('restart');\n  button.innerText = 'Restart';\n};\n\nconst hideMessageContainer = () => {\n  const messageContainer = [...document.querySelectorAll('.message')];\n  messageContainer.forEach((message) => message.classList.add('hidden'));\n};\n\nconst initializeGame = () => {\n  const startButton = document.querySelector('.button');\n\n  if (startButton) {\n    startButton.addEventListener('click', () => {\n      if (game.getStatus() === 'idle') {\n        game.start();\n\n        changeStartButton(startButton);\n        hideMessageContainer();\n      } else if (game.getStatus() === 'playing') {\n        game.restart();\n\n        game.start();\n      } else if (game.getStatus() === 'lose') {\n        game.restart();\n\n        game.start();\n        hideMessageContainer();\n      }\n    });\n  }\n};\n\ndocument.addEventListener('DOMContentLoaded', initializeGame);\n// eslint-disable-next-line no-shadow\ndocument.addEventListener('keydown', (event) => {\n  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {\n    event.preventDefault();\n  }\n\n  if (game.getStatus() !== 'playing') {\n    return;\n  }\n\n  switch (event.key) {\n    case 'ArrowUp':\n      game.moveUp();\n      break;\n    case 'ArrowDown':\n      game.moveDown();\n      break;\n    case 'ArrowLeft':\n      game.moveLeft();\n      break;\n    case 'ArrowRight':\n      game.moveRight();\n      break;\n  }\n\n  if (game.getStatus() === 'win' || game.getStatus() === 'lose') {\n    game.isGameOver();\n  }\n\n  game.updateTheScore();\n  game.updateTheBoard();\n});\n","/* eslint-disable no-console */\n/* eslint-disable padding-line-between-statements */\n'use strict';\n\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */\nclass Game {\n  /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */\n  constructor(initialState = []) {\n    if (initialState.length) {\n      this.initialState = initialState;\n    } else {\n      this.initialState = [\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n      ];\n    }\n    this.status = 'idle';\n    this.score = 0;\n    this.currentState = this.initialState.map((row) => [...row]);\n  }\n\n  /**\n   * Checks the games status and shows win/lose message\n   */\n  isGameOver() {\n    if (this.getStatus() === 'lose') {\n      document.querySelector('.message-lose').classList.remove('hidden');\n    } else if (this.getStatus() === 'win') {\n      document.querySelector('.message-win').classList.remove('hidden');\n    }\n  }\n\n  /**\n   *\n   * @returns true if there is 2048 tile on the field, false otherwise\n   */\n  checkWinCondition() {\n    return this.currentState.some((row) => row.includes(2048));\n  }\n\n  /**\n   *\n   * @returns true if player has at least 1 move, othrwise false\n   */\n  checkMovePossibility() {\n    if (this.getEmptyCellsCoordinates().length > 0) {\n      return true;\n    }\n\n    for (let row = 0; row < 4; row++) {\n      for (let col = 0; col < 4; col++) {\n        const currentValue = this.checkCellByCoordinates([row, col]);\n\n        if (\n          col < 3 &&\n          currentValue === this.checkCellByCoordinates([row, col + 1])\n        ) {\n          return true;\n        }\n\n        if (\n          row < 3 &&\n          currentValue === this.checkCellByCoordinates([row + 1, col])\n        ) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @description Moves all tiles down.\n   * Starting from the bottom-right corner, moving left and up,\n   * each non-empty cell is moved down as far as possible\n   * and merged if applicable.\n   * After the movement, a new tile is generated and the board is updated.\n   */\n  moveDown() {\n    if (this.getStatus() !== 'playing') {\n      return;\n    }\n\n    const previousState = JSON.stringify(this.currentState);\n\n    for (let col = 3; col >= 0; col--) {\n      const mergedThisMove = [false, false, false, false];\n\n      for (let row = 3; row >= 0; row--) {\n        const currentValue = this.checkCellByCoordinates([row, col]);\n\n        if (currentValue !== 0) {\n          let currentRow = row;\n          let nextRow = currentRow + 1;\n\n          // Move the tile down until it hits a non-empty cell\n          //  or the bottom of the board\n          while (\n            nextRow <= 3 &&\n            this.checkCellByCoordinates([nextRow, col]) === 0\n          ) {\n            this.currentState[nextRow][col] = currentValue;\n            this.currentState[currentRow][col] = 0;\n            currentRow = nextRow;\n            nextRow++;\n          }\n\n          // Check for a possible merge\n          if (\n            nextRow <= 3 &&\n            this.checkCellByCoordinates([nextRow, col]) === currentValue &&\n            !mergedThisMove[nextRow]\n          ) {\n            // Merge\n            this.currentState[nextRow][col] *= 2;\n            this.currentState[currentRow][col] = 0;\n            this.score += this.currentState[nextRow][col];\n            mergedThisMove[nextRow] = true;\n          }\n        }\n      }\n    }\n\n    const newState = JSON.stringify(this.currentState);\n\n    if (previousState === newState) {\n      return;\n    }\n\n    if (this.checkWinCondition()) {\n      this.status = 'win';\n    }\n\n    this.generateAndPositionNewTile();\n    this.updateTheBoard();\n\n    if (!this.checkMovePossibility()) {\n      this.status = 'lose';\n    }\n  }\n\n  /**\n   * @description Moves all tiles up.\n   * Starting from the top-left corner, moving right and down,\n   * each non-empty cell is moved up as far as possible\n   * and merged if applicable.\n   * After the movement, a new tile is generated and the board is updated.\n   */\n  moveUp() {\n    if (this.getStatus() !== 'playing') {\n      return;\n    }\n\n    const previousState = JSON.stringify(this.currentState);\n\n    for (let col = 0; col < 4; col++) {\n      const mergedThisMove = [false, false, false, false];\n\n      for (let row = 0; row < 4; row++) {\n        const currentValue = this.checkCellByCoordinates([row, col]);\n\n        if (currentValue !== 0) {\n          let currentRow = row;\n          let nextRow = currentRow - 1;\n\n          // Move the tile up until it hits a non-empty cell\n          // or the top of the board\n          while (\n            nextRow >= 0 &&\n            this.checkCellByCoordinates([nextRow, col]) === 0\n          ) {\n            this.currentState[nextRow][col] = currentValue;\n            this.currentState[currentRow][col] = 0;\n            currentRow = nextRow;\n            nextRow--;\n          }\n\n          // Check for a possible merge\n          if (\n            nextRow >= 0 &&\n            this.checkCellByCoordinates([nextRow, col]) === currentValue &&\n            !mergedThisMove[nextRow]\n          ) {\n            // Merge\n            this.currentState[nextRow][col] *= 2;\n            this.currentState[currentRow][col] = 0;\n            this.score += this.currentState[nextRow][col];\n            mergedThisMove[nextRow] = true;\n          }\n        }\n      }\n    }\n\n    const newState = JSON.stringify(this.currentState);\n\n    if (previousState === newState) {\n      return;\n    }\n\n    if (this.checkWinCondition()) {\n      this.status = 'win';\n    }\n\n    this.generateAndPositionNewTile();\n    this.updateTheBoard();\n\n    if (!this.checkMovePossibility()) {\n      this.status = 'lose';\n    }\n  }\n\n  /**\n   * @description Moves all tiles left.\n   * Starting from the top-left corner, moving right and down,\n   * each non-empty cell is moved left as far as possible\n   * and merged if applicable.\n   * After the movement, a new tile is generated and the board is updated.\n   */\n  moveLeft() {\n    if (this.getStatus() !== 'playing') {\n      return;\n    }\n\n    const previousState = JSON.stringify(this.currentState);\n\n    for (let row = 0; row < 4; row++) {\n      let newRow = this.currentState[row].filter((cell) => cell !== 0);\n      newRow = [...newRow, ...Array(4 - newRow.length).fill(0)];\n      this.currentState[row] = newRow;\n\n      const mergedThisMove = [false, false, false, false];\n\n      for (let col = 0; col < 3; col++) {\n        const currentValue = this.checkCellByCoordinates([row, col]);\n\n        if (\n          currentValue !== 0 &&\n          this.checkCellByCoordinates([row, col + 1]) === currentValue &&\n          !mergedThisMove[col]\n        ) {\n          this.currentState[row][col] *= 2;\n          this.currentState[row][col + 1] = 0;\n          this.score += this.currentState[row][col];\n          mergedThisMove[col] = true;\n        }\n      }\n\n      newRow = this.currentState[row].filter((cell) => cell !== 0);\n      newRow = [...newRow, ...Array(4 - newRow.length).fill(0)];\n      this.currentState[row] = newRow;\n    }\n\n    const newState = JSON.stringify(this.currentState);\n\n    if (previousState === newState) {\n      return;\n    }\n\n    if (this.checkWinCondition()) {\n      this.status = 'win';\n    }\n\n    this.generateAndPositionNewTile();\n    this.updateTheBoard();\n\n    if (!this.checkMovePossibility()) {\n      this.status = 'lose';\n    }\n  }\n\n  /**\n   * @description Moves all tiles right.\n   * Starting from the top-right corner, moving left and down,\n   * each non-empty cell is moved right as far as possible\n   * and merged if applicable.\n   * After the movement, a new tile is generated and the board is updated.\n   */\n  moveRight() {\n    if (this.getStatus() !== 'playing') {\n      return;\n    }\n\n    const previousState = JSON.stringify(this.currentState);\n\n    for (let row = 0; row < 4; row++) {\n      let newRow = this.currentState[row].filter((cell) => cell !== 0);\n      newRow = [...Array(4 - newRow.length).fill(0), ...newRow];\n      this.currentState[row] = newRow;\n\n      const mergedThisMove = [false, false, false, false];\n\n      for (let col = 3; col > 0; col--) {\n        const currentValue = this.checkCellByCoordinates([row, col]);\n\n        if (\n          currentValue !== 0 &&\n          this.checkCellByCoordinates([row, col - 1]) === currentValue &&\n          !mergedThisMove[col]\n        ) {\n          this.currentState[row][col] *= 2;\n          this.currentState[row][col - 1] = 0;\n          this.score += this.currentState[row][col];\n          mergedThisMove[col] = true;\n        }\n      }\n\n      newRow = this.currentState[row].filter((cell) => cell !== 0);\n      newRow = [...Array(4 - newRow.length).fill(0), ...newRow];\n      this.currentState[row] = newRow;\n    }\n\n    const newState = JSON.stringify(this.currentState);\n\n    if (previousState === newState) {\n      return;\n    }\n\n    if (this.checkWinCondition()) {\n      this.status = 'win';\n    }\n\n    this.generateAndPositionNewTile();\n    this.updateTheBoard();\n\n    if (!this.checkMovePossibility()) {\n      this.status = 'lose';\n    }\n  }\n\n  /**\n   * @description Simply holds an update of the visual score,\n   * called after each move in the main file.\n   */\n  updateTheScore() {\n    const scoreElement = document.querySelector('.game-score');\n    scoreElement.innerText = this.score;\n  }\n  /**\n   * @returns {number} returns game score.\n   */\n  getScore() {\n    return this.score;\n  }\n\n  /**\n   * @returns {number[][]} returns current game board state.\n   */\n  getState() {\n    return this.currentState;\n  }\n\n  /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */\n  getStatus() {\n    return this.status;\n  }\n\n  /**\n   * Calls two\n   *  @method generateNewTile\n   *\n   * and\n   *  @method positionNewTile\n   *\n   * in a chain to simplify the code read.\n   */\n  generateAndPositionNewTile() {\n    this.positionNewTile(this.generateNewTile());\n  }\n  /**\n   * Creates and positions 2 new cells on the field.\n   */\n  initializeBoard() {\n    this.generateAndPositionNewTile();\n    this.generateAndPositionNewTile();\n  }\n\n  /**\n   * @description Starts the game.\n   * Changing a status, initializing the board with 2 random cells\n   * and updating UI.\n   */\n  start() {\n    this.status = 'playing';\n    this.initializeBoard();\n    this.updateTheBoard();\n  }\n\n  /**\n   * @description Resets the game.\n   * Setting a score to 0, clearing the field and calling a start() again.\n   */\n  restart() {\n    this.score = 0;\n    this.status = 'idle';\n    this.currentState = this.initialState.map((row) => [...row]);\n    this.updateTheBoard();\n    // this.updateTheScore();\n  }\n\n  /**\n   * @description Mapping through all non-empty cells, asiging 0 value to them,\n   * calling updateTheBoard() which check and fixes the styles\n   */\n  resetTheField() {\n    const cellsToReset = this.getNonEmptyCells();\n    const currentFieldState = this.getState();\n\n    cellsToReset.forEach((cell) => {\n      currentFieldState[cell[0]][cell[1]] = 0;\n    });\n\n    this.updateTheBoard();\n  }\n\n  /**\n   * @returns {number} 2 or 4, 4 has 10% chance to be generated\n   */\n  generateNewTile() {\n    return Math.random() < 0.1 ? 4 : 2;\n  }\n\n  /**\n   * Sets new random position for the passed cellValue\n   * from available empty cell spots\n   * @param {number} newTileValue - number value of new cell to place\n   * @example 2, 4, 8, etc\n   */\n  positionNewTile(newTileValue) {\n    const availableFields = this.getEmptyCellsCoordinates();\n\n    const position =\n      availableFields[Math.floor(Math.random() * availableFields.length)];\n\n    if (availableFields.length) {\n      this.getState()[position[0]][position[1]] = newTileValue;\n    } else {\n      this.checkMovePossibility();\n    }\n  }\n\n  /**\n   * @example[[0, 1], [3,2]] etc\n   * @returns {number[][]} returns all empty cell coordinates array\n   */\n  getEmptyCellsCoordinates() {\n    const possibleCoordinates = [];\n\n    for (let row = 0; row < this.getState().length; row++) {\n      for (let cell = 0; cell < this.getState()[row].length; cell++) {\n        if (this.currentState[row][cell] === 0) {\n          possibleCoordinates.push([row, cell]);\n        }\n      }\n    }\n\n    return possibleCoordinates;\n  }\n\n  /**\n   * @example [[0, 1], [3,2]] etc\n   * @returns {number[][]} returns all non-empty cell coordinates array\n   */\n  getNonEmptyCells() {\n    const cellsCoordinates = [];\n\n    for (let row = 0; row < this.getState().length; row++) {\n      for (let cell = 0; cell < this.getState()[row].length; cell++) {\n        if (this.currentState[row][cell] !== 0) {\n          cellsCoordinates.push([row, cell]);\n        }\n      }\n    }\n\n    return cellsCoordinates;\n  }\n\n  /**\n   * @param {number[]} coordinatesToCheck - array of the cell coordinates\n   *  [x, y]\n   * @returns {number} cell value by the coordinates\n   */\n  checkCellByCoordinates([row, col]) {\n    if (row >= 0 && row < 4 && col >= 0 && col < 4) {\n      return this.currentState[row][col];\n    }\n    return null;\n  }\n\n  /**\n   * Updates UI of the board.\n   * @description Mapping through all rows/cells, clearing previous styles,\n   * changing cells according to updated game board.\n   */\n  updateTheBoard() {\n    const gameField = [...document.querySelectorAll('tr.field-row')];\n    const rows = this.currentState;\n\n    if (gameField.length === 0) {\n      return;\n    }\n\n    // Going through rows\n    for (let i = 0; i < rows.length; i++) {\n      // Going through cells in row\n      for (let j = 0; j < rows[i].length; j++) {\n        const currentCell = gameField[i].children[j];\n        const currentDataCell = rows[i][j];\n\n        // Removing all previous classes and setting a base class for the cell\n        currentCell.className = 'field-cell';\n\n        // Adding an extra class, if cell is not empty\n        if (currentDataCell !== 0) {\n          currentCell.classList.add(`field-cell--${currentDataCell}`);\n          currentCell.innerText = currentDataCell;\n        } else {\n          currentCell.innerText = '';\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = Game;\n"],"names":["a","$a5fd07fa01589658$exports","$09e991522ca7e64e$var$game","constructor","initialState","length","status","score","currentState","map","row","isGameOver","getStatus","document","querySelector","classList","remove","checkWinCondition","some","includes","checkMovePossibility","getEmptyCellsCoordinates","col","currentValue","checkCellByCoordinates","moveDown","previousState","JSON","stringify","mergedThisMove","currentRow","nextRow","generateAndPositionNewTile","updateTheBoard","moveUp","moveLeft","newRow","filter","cell","Array","fill","moveRight","updateTheScore","scoreElement","innerText","getScore","getState","positionNewTile","generateNewTile","initializeBoard","start","restart","resetTheField","cellsToReset","getNonEmptyCells","currentFieldState","forEach","Math","random","newTileValue","availableFields","position","floor","possibleCoordinates","push","cellsCoordinates","gameField","querySelectorAll","rows","i","j","currentCell","children","currentDataCell","className","add","__esModule","default","$09e991522ca7e64e$var$changeStartButton","button","$09e991522ca7e64e$var$hideMessageContainer","messageContainer","message","addEventListener","startButton","event","key","preventDefault"],"version":3,"file":"index.39c388c7.js.map"}